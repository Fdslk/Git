---
title: 群智能优化算法
grammar_cjkRuby: true
---
### *2017/07/17*
群体智能的特点：
1.简单性
2.分布式
3.鲁棒性
4.良好的可扩展性（群体智能系统中的个体不仅可以进行相互之间的直接通信，还可以通过环境进行直接通信，集合体之间通过所处的小环境作为媒介进行交互，具有自组织性，这样就使得整个系统具备良好的可扩展性）
5.广泛的适应性
                                      
群智能算法的优点：
1.算法思想简单且以实现；
2.一份直接的信息交流方式确保了系统的扩展性
3.具有并行性和分布式的特点，可利用多处理器予以实现
4.对问题定义的连续性无特殊要求，可处理离散域的问题
5.无集中控制约束，不会因为个别个体的故障影响整个问题的求解，确保了系统具备更强的鲁棒性

*PSO（particle swarm optimization）算法理论基础的基本要素：*
1.刺激的评价
2.与邻近的比较
3.对领先近邻的模仿

*蚁群优化ACO（Ant colony optimization）算法*：某一路经上走过的蚂蚁越多，则后来这选择该路径的概率就越大（在这个算法中存在一种*正反馈效应*）。

*人工蜂群算法（Artificial Bee Colony ABC）算法*：建立在蜜蜂自组织模型和群体智能基础上的一种非数值优化计算方法，蜜蜂根据各自的分工进行不同的活动，并实现蜂群信息的共享和交流，从而找到问题的最优解。

ABC on propagating 模拟蜜蜂繁殖机理的蜂群算法
ABC on foraging 模拟蜜蜂采蜜（觅食）机理的蜂群算法：单个昆虫个体的行为及其简单，但是有单个简单的个体所组成的群体queen表现出及其复杂的行为，真实的蜜蜂种群能够在任何环境下，以极高的效率从蜜源（花朵）中采集花蜜，同时，他们能够很好的适应环境的变化。

优点：以自然界中蜂群的自组织模型和气体只能为基础的一种仿生算法。主要特点是不需要了解问题的特殊信息，只需要对问题进行优劣的比较。通过各人工蜂个体的局部寻优行为，最终在群体中使全局最优质凸显出来，算法具有较快的收敛速度。

*人工鱼群算法*：与生存的数目最多的地方一般是本水域中富含营养物质的地方，依据这一特点来模仿鱼群的觅食等行为，从而实现全局寻优，这就是人工鱼群（Artificial Fish School，AF）算法。

*细菌觅食优化算法（Bacteria Foraging OptimizationBFO）*：生物学基础是人类肠道中大肠杆菌在觅食过程中体现出来的智能行为。
首先要对所求问题的解进行适当的编码，然后充分利用群体的信息对个体进行操作，或者达到获得最优解或近似最优解的目的。

细菌觅食算法求解优化问题的一般过程：
1.对问题的各个解进行编码
2.设计评价函数
3.产生初始解群里
4.利用群体的相互影响进行优化
![enter description here][1]

### *2017/7/18*
经典优化理论与方法

线性规划：
1.凸集和凸函数
凸集：实数R（或复数C上）的向量空间中，如果集合S中任两点的连线上的点都在S内，则称集合S为凸集。
凸函数：连接函数曲线上任意两点的弦不在曲线的下方。

非线性规划：
对实际规划问题做定量分析，必须建立数学模型，建立数学模型首先要选定适当的目标变量和决策变量，并建立目标变量和决策变量之前的函数关系，称之为目标函数。然后将各种限制条件加以抽象，得出决策变量应满足的一些等式或不等式，称之为约束条件。


### *2017/7/19*
整数规划：
在实际问题所建立的数学模型旺旺遇到，出目标函数和约束函数时线性函数外，还要求决策变量取整数值得情形，这类问题成为线性整数规划。如果要求所有变量取整数值，就是纯整数规划；如果要求部分变量取整数值，就称为混合整数规划；如果要求变量只取0-1，则称为0-1规划。
整数规划的一些重要方法
1.分支定界法：（松弛，分解，探测）
![enter description here][2]
2.割平面法：
首先求解整数规划的线性松弛问题，如果得到的最优解满足整数要求，则为整数规划的最优解；否则，选择一个不满足整数要扭的基变量，定义一个新约束，增加到原来的约束集中。这个约束的作用是切掉一部分不满足整数要求的可行解，缩小可行域，而保留全部整数可行解。然后，解新的松弛线性规划。重复以上工程，直至求出整数最优解。在这种方法中，关键问题是如何定义切割约束。

3.指派问题：运输问题中，若令m=n，ai = bj = 1，限定变量只取0或1，则得到一种重要的特殊情形。设有n项任务，指派n个人去完成，没人均承担一项任务，每项任务各由一个人来完成。由于劳动者的素质、效率集劳动质量各部相同，劳务费自然不相同，设第i个人完成第j项任务的劳务费为cij，试确定是总劳务费最少的分配方案。

### *2017/7/20*
原始-对偶算法：
	先给定对偶问题一个可行解，由此出发，设法求出原问题一个满足互补松弛的可行解。
可行解：（Cij - Ui - Vj）Xij = 0， i， j = 1,2， ...，n

动态规划：
	动态规划是运筹学的一个分支没事解决多阶段决策过程优化问题的一种数学方法，主要用于时间或低于划分阶段的动态过程的最优化。
常用术语：
	1.阶段：整个过程的自然划分，通常按照时间顺序或空间特征划分阶段。
	2.状态：整个过程中，每个阶段开始所处的自然状况或客观条件称为状态，是不可控因素。（某个阶段的状态给定后，这个阶段后续过程的发展不收这个阶段以前个阶段状态的影响，这种性质称为无后效性）
	3.决策：一个阶段的状态确定后，可以做出不同的选择，从而演变到下一阶段的某个状态。
	4.策略：决策组成的序列
	5.状态转移方程：
	![enter description here][3]
	6.标函数：指标函数时衡量过程优劣的数量指标，他是定义在全过程和所有后部子过程上的数量函数。
	7.最优策略和最优轨线
逆推解法和顺推解法：

#### 多目标优化

用最优化方法解决实际问题步骤：
1.提出最优化问题，收集有关数据和资料；
2.建立最优化问题的数学模型，确定变量，列出目标函数和约束条件
3.分析模型，选择合适的最优化方法
4.求解，一般通过编制程序，用计算机求解
5.最优解的检验和实施

## 三 智能优化方法

### 1 遗传算法（genetic algorithm）
特征：
1.进化发生在解的编码上，这些编码按生物学的属于称为染色体，由于进行了编码，优化问题的一切性质都通过编码来研究，编码和解码是遗传算法的一个主题。
2.自然选择规律决定哪些染色体产生超过平均数的后代，遗传算法中，通过优化问题的目标而人为地构造适应度函数，以达到好的的染色体产生超过平均数的后代的目的。
3.当染色体结合时，双亲的遗传基因的结合使得子女保持父母的特征
4.当染色体结合后，随机的编译会造成子代与父代的不同
![enter description here][4]

### *2017/7/21*
基本遗传算法的描述：
只使用选择算子，交叉算子，变异算子
遗传算法构成要素：
1.染色体编码方法，基本遗传算法使用固定长度的二进制符号来表示群体中的个体，其等位基因是由二值符号[0,1]所组成，初始群体中各个个体的基因值可用均匀分布的随机数来产生，ex：
	X = 10011100100010101
	这样就可以表示一个个体，该个体的染色体长度n=18
2.个体适应度评价，基本遗传算法按与个体适应度成正比的概率，来决定当前群体中每个个体遗传到下一代群体中的概率，为正确计算这个概率，这里要求所有的个体的适应度值必须非负。这样，根据不同种类的问题，必须预先确定好有目标函数值到个体适应度之间的转换规则，特别是要预先确定好目标函数值为负数时的处理方法。
3.遗传算子：
(1)选择运算使用比例选择算子；
(2)交叉运算使用单点交叉算子；
(3)变异运算使用基本位变异算子或均匀变异算子。
4.基本遗传算法的运行参数
（1）M-群体大小，群体中所含个体的数量 一般为20~100
（2）T-遗传运算的终止进化代数，一般为50~100
（3）Pc-交叉概率，一般为0.4~0.99
（4）Pm-变异概率，一般为0.0001~0.1
![enter description here][5]
基本遗传算法的实现：
1.个体适应度评价：个体适应度的值来确定该个体被遗传到下一代群体中的概率，个体的使用度越大，该个体被遗传到下一代个概率也就越大，反之，个体的使用度越小，该个体被遗传到下一代概率也就越小，基本遗传算法使用比例选择算子来确定群体中各个个体遗传到下一代群体中的数量，为正确计算不同情况下各个个体的遗传概率要求所有的适应度值必须非负。
对于这个非负的要求有两种方法：一是去一个比较小的数进行相加，这个比较小的数可以由以下方法得到，预先指定的一个较小的数，进化到当前代位置的最小目标函数值，当前代或最近几代群体中的最小目标函数值；二是取一个比较大的数进行相减，这个比较大的数获取的方法与较小数获取的方法相反。

2.比例选择算子：从当代群体中选择出一下比较优良的个体，并将其复制到下一代群体中，最常用和最基本的选择算子是比例选择算子，所谓比例选择算子，是指个体被选中并遗传到下一代群体中的概率与该个体的适应度值成正比。

3.单点交叉算子：S1：对群体中的个体进行两两随机配对，若群体大小为M，则共有[M/2]对相互配对的个体组，其中[x]表示不大于x的最大的整数。S2：对每一对相互配对的个体，随机设置某一基因座前的位置为交叉点，若染色体的长度为n，则共有n-1对可能的交叉点位置。S3：每一对相互配对的个体，依设定的交叉概率Pc，再其交叉点处相互交叉两个个体的部分染色体，从而产生两个新的个体。
![enter description here][6]

4.基本位变异算子：对于基本遗传算法中用二进制编码符号串所表示的个体，若需要进行编译操作的某一基因座上的原有基因值为0，则变异操作将该基因值变为1；反之，若原有基因值为1，则变异操作将其变为0。
![enter description here][7]

遗传算法应用步骤：反复将选择算子，交叉算子，变异算子作用于群体，最终可得到问题的最优解或近似最优解。
S1：确定决策变量及其各种约束条件，及确定出个体的表现型和问题的解空间。
S2：建立优化模型，即确定出目标函数的类型（是求目标函数的最大值还是求目标函数的最小值）及其数学描述形式或量化方法。
S3：确定表示可行解的染色体编码方式，即确定出个体的基因型X及遗传算法的搜索空间。
S4：确定编码方法，即确定出有个个体基因型X到个体表现型X的对应关系或转换关系方法。
S5：确定个体适应的量化评价方法，即确定出有目标函数f（X）到个体适应度函数F（X）的转换规则
S6：设计遗传算子，即确定出选择运算，交叉运算，变异运算等遗传算子的具体操作方法
S7：确定遗传算法的有关运行参数
![enter description here][8]

### *2017/7/28*
模拟退火算法（Simulated Annealing algorithm SA）：对局部搜索算法的扩展，与一般局部搜索算法不同，SA算法是以一定的概率选择领域中目标值较小的状态，从理论上来说，是一个全局最优算法。
![enter description here][9]
退火算法的每一次迭代都体现了集中和扩散两个策略的平衡，对遇到的下一个迭代解，如果这个解更好，则采用集中策略，选择这个解为新解，否则，采用扩散策略，以某一概率选择这个解为新解。
	模拟退火算法主要可以分为两类，第一类为时齐算法，基本计算框架是在![enter description here][10]中对每一个固定的t，计算对应的马尔可夫链，直至达到一个稳定状态，然后在让温度下降；第二类为非时齐算法，基本计算框架是有一个马尔可夫链组成，要求在两个相邻的转移中，温度t是下降的。
	无论是从实际的角度还是从直观的角度出发，描述模拟退火过程的马尔可夫链应满足下列条件：
	1.可达性，无论起点如何，任何一个状态都可以到达。
	2.渐近不依赖起点，由于起点的选择有非常大的随机性，我们的目的是达到全局最优，
	3.分布稳定性，包含两个内容，一是温度不变时，其马尔可夫链的极限分布存在；二是当温度渐近0时，其马尔可夫链也有极限分布。


### *禁忌搜索算法 Tabu Search Algorithm*
局部领域搜索算法的推广，是人工智能在组合最优化算法中的一个成功应该用。禁忌搜索算法充分体现了集中和扩散两个策略，他的集中策略体现在局部搜索，即从一点出发，在这点的邻域内寻求根号的解，以达到最优解而结束，为了跳出局部最优解，扩散策略通过禁忌表的的功能来实现，禁忌表中记录已经到达点的某些信息，算法通过对禁忌表中的禁忌，而达到一些没有搜索的点，从而实现更大区域的搜索。


### *蚁群优化算法*
利用蚁群所留下的信息素，进行正反馈
重要特点：基本蚁群优化算法是一个系统；分布式计算；自组织；正反馈
![enter description here][11]

### *人工鱼群算法*
实现步骤：
![enter description here][12]

### *人工蜂群算法*
算法步骤：
![enter description here][13]

### *细菌觅食优化算法*
1.该算法主要是通过趋向性操作，复制操作和迁徙操作3种迭代计算来求解问题
趋向性操作：决定算法的前进方向以及在某个区域搜索的详细程度，是算法的核心操作，也是设计算法是需要重点考虑的部分，目前，设计趋向性操作时采用最多的是引入自适应机制。
![enter description here][14]
2.赋值操作：
![enter description here][15]
3.迁徙操作：
![enter description here][16]
细菌觅食算法流程图：
![enter description here][17]


### *DNA计算*
充分利用了DNA分子具有的*海量存储能力*，以及其生化反应具有的*高度并行性*，这成为DNA计算的两大优点
机理：通过对DNA分子的编码，将要解决问题的信息存储在DNA链上，这些DNA链在可控的生化环境中进行有序并行的组合，最终形成稳定状态的DNA分子，这些DNA分子表达了所求问题的解的信息，最后对这些信息进行解读得到问题的解。


### *2017/7/29*
## *粒子群优化算法*
PSO算法首先随机初始化一群粒子（随机解），在每个一次迭代中，粒子通过跟踪两个极值跟新自己：一个是粒子本身所找到的最优解，叫做个体极值点（用pbest表示其位置）；另一个是整个种群目前找到的最优解，称为全局极值点（用gbest表示其位置），而局部PSO算法不用整个种群，仅用其中一部分邻近粒子，所有邻居中的最优解就是局部极值点（用lbest表示其位置）。
![enter description here][18]
每一维粒子的速度都会被限制在一个最大速度Vmax，如果某一维跟新后的速度超过用户设定的Vmax，那么这一维的速度就被设定为Vmax。粒子群优化算法将每一个可能产生的解表述为群中的一个粒子，每个粒子都具有自己的位置向量和速度向量，每个位置都代表着一个参数值，因此，对一个N维优化问题而言，在N维空间中的每一位置的粒子都代表着优化问题中的一个解，而位置就代表着被等待优化调整的参数

*加惯性权重的PSO算法*
使粒子保持运动惯性，使其有扩展搜索空间得趋势，有能力探索新的预期，对基本粒子群优化算法进行改进，既对速度跟新方程加惯性权重w，称之为标准PSO算法。
1.线性调整w的策略
先采用全局搜索，使搜索空间快速收敛于某一区域，然后采用局部精细搜索以获得高精度的解，在等式![enter description here][19]中的Vi前乘以惯性权重w，w较大，则算法具有较强的全局搜索能力；w较小，则算法倾向于局部搜索，w调整公式为
![enter description here][20]
Wmax，Wmin分别是w的最大值和最小值，iter和iter（max）分贝是当前迭代次数和最大迭代次数，一般做法是，将w初始化为0.9并使其岁迭代次数的增加线性递减至0.4，以达到上述期望的优化目的。
2.模糊调整w的策略：优缺点，模糊推理机能预测合适的w，动态平衡全局和局部搜索能力，极大地提高了平均适应度值，但是其参数比较多，增加了算法的复杂度，是的其实现较为困难。
3.随机调整w的策略：![enter description here][21]

*带收缩因子的PSO算法*
收缩因子X有助于确保PSO算法收敛，速度跟新方程描述如下：
![enter description here][22]
收缩因子控制系统行为最终收敛，且可以有效搜索不同的区域，是算法能得到高质量的解。

### *2017/8/10*
1.基本粒子群优化算法收敛性分析
	粒子的位置数值可能无限增加，也就是粒子系统发散，但发散的粒子系统未必无界，比如，一个序列可能在一定的数值范围内不断震荡，但却永远不收敛。
2.带收缩因子的PSO算法的收敛性分析
可使粒子轨迹收敛，而不需限定粒子的速度
粒子运动轨迹对收敛性的影响
![enter description here][23]
该定义表明，粒子收敛是指粒子最终停留在搜索空间内某一固定位置p，即所有粒子都将最终收敛到全局最优粒子所在的位置，这一结论揭示了粒子群优化算方的中的gbest是整个粒子群的“吸引子”，其中gbest自身也随算法的运行不断改变。如果粒子群中的所有粒子都达到收敛，此时，整个粒子群也就不再变化，达到稳定状态。

### *2017/8/5*
## 群智能聚类融合算法与PPI网络
### 其他（鸽子算法）主要算子：
1.地图罗盘算子：通过计算随机产生鸽子（实际上就是产生鸽子个初始位置和初始速度）
2.地标算子（）
在这里也要计算鸽子的适应度


### *2017/8/7*
基于鸽子优化算法的聚类模型
阶段一：地图罗盘操作阶段先通过全局探索找到核心的种子节点
阶段二：在地标算子的迭代过程中将附件蛋白质不断聚到核心簇中最终形成蛋白质复合物。
考虑的蛋白质复合特征有三个，核心附件结构，复合物内部蛋白质间最短距离不超过2，蛋白质复合物是个高密度的簇。
![enter description here][24]

FA（Firefly algorithm）仿生原理：萤火虫通过荧光素发生的复杂生化反应进行
发光，借助发光捕食、求偶、警示以及相互交流等，萤火虫算法就是模拟萤火虫的发光行为提出的启发式随机优化算法。
重要参数：萤火虫的亮度和吸引度

ＦＡ 算法的描述
萤火虫的亮度和目标函数值相关，体现了萤火虫所处位置的优劣，位置越佳目标值越好，亮度越高，亮度高的萤火虫吸引亮度低的萤火虫向自己移动，移动的大小由吸引度来衡量，可见，亮度决定移动方向，吸引度决定移动大小。


### *2017/8/10*
## 群智能优化算法与生物序列比对
序列对比是生物信息学中最重要也是最基本的研究内容之一，它包含序列组成（特别是涉及基因层次方面）分析和序列之间的比较分析两个方面的内容，序列对比的定义，简单地说们就是通过在序列组中各条序列的适当位置插入空格，是所有序列的长度在达到一致的同时还能获得最大的序列相似度，找出序列中功能或结构的相似性区域，从而进一步推测出序列之间的相互关系。

序列比对算法：***精确比对算法***（完全基于动态规划思想，考虑到所有可能的比对结果。然后从中选择相似性最高的比对作为解，其中最经典的是双序列比对全局算法和双序列比对局部算法）、***渐近比对算法***（首先选取关系最近的两条序列进行比较，然后再从剩下的序列中逐步添加，直到所有序列都添加进去。）、***基于图论的比对算法***（主要代表是偏序比对）、***迭代比对算法***（基于一个可以产生序列比对的方法，给定一个循环条件及优化解的方法，从而将初始解的值来能够提高，直到比对结果不在改善；该方法主要用于求解多序列比对问题）。


### ***Needleman-Wunsch Algorithm***
ps：如果参与比对的是长度互不相同的几条序列，则需要采用一些方法在序列的某些位置插入空格，从而使序列的长度达到一致。
基本思想：使用递归的方法计算出两条序列所有可能的比对结果的相似度得分，同时将该得分存储在某个矩阵中，该矩阵称为得分矩阵。
利用相关公式先画出得分矩阵，然后根据动态规划中回溯法，得到最优比对序列

### ***Smith-Waterman Algorithm***
该算法是由Needleman-Wunsch改进而来的。是经典的双虚列局部比对算法，适用于亲缘关系较远、整体上不具有相似性但在一些较小的区域上存在局部相似性的两条序列。与Needleman-Wunsch算法不同的是，得分函数有所变化
![enter description here][25]


### 多序列比对
在基本PSO的多序列比对算法的基础上，引入混沌PSO算法，使PSO算法中易出现的早熟早收敛问题得到一定程度的解决，针对多序列比对问题的SP优化模型，提出来基于混沌粒子群优化的多序列比对算法。
1.混沌粒子群优化（CPSO）算法
有混沌序列具有遍历性的特点，可在迭代中产生局部最优解的许多领域点，帮助惰性粒子逃离局部极小点，并快速搜寻最优解，因此，为了使粒子能够跳出停滞状态，应由有活力的新粒子取代惰性粒子，即当判断PSO算法发生早熟收敛是，利用混沌搜索对当前种群中的某个粒子进行跟新，增加种群的多样性。


  [1]: ./images/1500277810157.jpg "1500277810157.jpg"
  [2]: ./images/1500433755874.jpg "1500433755874.jpg"
  [3]: ./images/1500536408839.jpg "1500536408839.jpg"
  [4]: ./images/1500539657903.jpg "1500539657903.jpg"
  [5]: ./images/1500604159476.jpg "1500604159476.jpg"
  [6]: ./images/1500606017348.jpg "1500606017348.jpg"
  [7]: ./images/1500606880589.jpg "1500606880589.jpg"
  [8]: ./images/1500607496962.jpg "1500607496962.jpg"
  [9]: ./images/1501215200023.jpg "1501215200023.jpg"
  [10]: ./images/1501215890304.jpg "1501215890304.jpg"
  [11]: ./images/1501226392871.jpg "1501226392871.jpg"
  [12]: ./images/1501226833905.jpg "1501226833905.jpg"
  [13]: ./images/1501227534589.jpg "1501227534589.jpg"
  [14]: ./images/1501227996801.jpg "1501227996801.jpg"
  [15]: ./images/1501228019219.jpg "1501228019219.jpg"
  [16]: ./images/1501228099042.jpg "1501228099042.jpg"
  [17]: ./images/1501228128091.jpg "1501228128091.jpg"
  [18]: ./images/1501324112495.jpg "1501324112495.jpg"
  [19]: ./images/1501324112495.jpg "1501324112495.jpg"
  [20]: ./images/1501324229285.jpg "1501324229285.jpg"
  [21]: ./images/1501324749431.jpg "1501324749431.jpg"
  [22]: ./images/1501325135885.jpg "1501325135885.jpg"
  [23]: ./images/1502351566302.jpg "1502351566302.jpg"
  [24]: ./images/1502068573772.jpg "1502068573772.jpg"
  [25]: ./images/1502342393558.jpg "1502342393558.jpg"